package com.andreev.spring.rest.service;

import com.andreev.spring.rest.dao.schema.SchemaRepository;
import com.andreev.spring.rest.dto.ColumnsInfoDto;
import com.andreev.spring.rest.dto.TableDto;
import com.andreev.spring.rest.dto.TableStructureDto;
import lombok.extern.jbosslog.JBossLog;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

import java.util.List;
import java.util.Locale;
import java.util.stream.Collectors;

@Service
@JBossLog
public class SchemaService {

    private final SchemaRepository schemaRepository;

    @Autowired
    public SchemaService(SchemaRepository schemaRepository) {
        this.schemaRepository = schemaRepository;
    }

    public Mono<ResponseEntity<Void>> createTable(List<TableDto> tableDtoList) {
        return Mono.fromCallable(() -> {
            if (!tableDtoList.isEmpty()) {
                try {
                    for (TableDto tableDto : tableDtoList) {
                        String query = buildCreateTableQuery(tableDto);
                        log.infov("Query text: {0}", query);
                        schemaRepository.createTable(query);
                    }
                    return new ResponseEntity<Void>(HttpStatus.CREATED);
                } catch (Exception ex) {
                    log.infov("Error while create new table: {0}", ex.toString());
                    return new ResponseEntity<Void>(HttpStatus.NOT_ACCEPTABLE);
                }
            } else return new ResponseEntity<Void>(HttpStatus.NOT_ACCEPTABLE);
        }).publishOn(Schedulers.boundedElastic());
    }

    private String buildCreateTableQuery(TableDto tableDto) {
        StringBuilder sb = new StringBuilder();
        sb.append("CREATE TABLE ").append("\"").append(tableDto.getTableName()).append("\"")
                .append(" (");
        List<ColumnsInfoDto> columnsInfo = tableDto.getColumnsInfo();
        for (int i=0;i<columnsInfo.size();i++) {
            sb.append(columnsInfo.get(i).getTitle()).append(" ").append(columnsInfo.get(i).getType());
            if (columnsInfo.get(i).getTitle().equals(tableDto.getPrimaryKey())) {
                sb.append(" PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY");
            }
            if(tableDto.getColumnsInfo().size() - 1 != i) {
                sb.append(", ");
            }
        }
        sb.append(");");
        return sb.toString();
    }

    public Mono<ResponseEntity<Object>> getTableByName(String tableName) {
        return Mono.fromCallable(() -> {
            if (tableName != null) {
                List<TableStructureDto> tableStructureDtoList = schemaRepository.getTableByName(tableName);
                log.infov("Table found: {0}", tableStructureDtoList);
                if (tableStructureDtoList.isEmpty()) {
                    return new ResponseEntity<>(null, HttpStatus.OK);
                }
                TableDto tableDto = new TableDto();
                tableDto.setTableName(tableName);
                tableDto.setColumnsAmount(tableStructureDtoList.size());
                tableDto.setPrimaryKey(tableStructureDtoList.stream()
                        .filter(column -> column.getIsidentity().equals("YES")).findFirst()
                        .get().getColumnname().toLowerCase());
                List<ColumnsInfoDto> columnsInfoDtoList = tableStructureDtoList.stream()
                        .map(column -> new ColumnsInfoDto(column.getColumnname().toUpperCase(),
                                column.getDatatype().toUpperCase())).collect(Collectors.toList());
                tableDto.setColumnsInfo(columnsInfoDtoList);
                return new ResponseEntity<Object>(tableDto, HttpStatus.CREATED);
            } else return new ResponseEntity<>(null, HttpStatus.OK);
        }).publishOn(Schedulers.boundedElastic());
    }

    public Mono<ResponseEntity<Void>> deleteTableByName(String tableName) {
        return Mono.fromCallable(() -> {
            if (tableName != null) {
                try {
                    schemaRepository.deleteTableByName(tableName);
                    return new ResponseEntity<Void>(HttpStatus.CREATED);
                } catch (Exception ex) {
                    log.errorv("Table can not be delete: {0}", ex);
                    return new ResponseEntity<Void>(HttpStatus.NOT_ACCEPTABLE);
                }
            } else return new ResponseEntity<Void>(HttpStatus.NOT_ACCEPTABLE);
        }).publishOn(Schedulers.boundedElastic());
    }

    public void executeCustomQuery(String query) {
        schemaRepository.executeCustomQuery(query);
    }
}
